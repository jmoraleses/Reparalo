
import { createClient } from '@supabase/supabase-js';
import { Database } from '../src/integrations/supabase/types';
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load env vars
const envPath = path.resolve(__dirname, '../.env');
if (fs.existsSync(envPath)) {
    dotenv.config({ path: envPath });
} else {
    console.error('.env file not found!');
    process.exit(1);
}

const supabaseUrl = process.env.VITE_SUPABASE_URL!;
const supabaseKey = process.env.VITE_SUPABASE_PUBLISHABLE_KEY!;

const TIMESTAMP = Date.now();
const USERS = {
    client: {
        email: `client.${TIMESTAMP}@example.com`,
        password: 'password123',
        name: `Cliente Test ${TIMESTAMP}`,
        is_workshop: false
    },
    workshop: {
        email: `workshop.${TIMESTAMP}@example.com`,
        password: 'password123',
        name: `Taller Test ${TIMESTAMP}`,
        is_workshop: true,
        workshop_name: `Taller AutoGenerated ${TIMESTAMP}`,
        workshop_city: 'Madrid'
    }
};

const REQUEST_STATES = [
    'esperando_ofertas',
    'oferta_seleccionada',
    'en_camino_taller',
    'diagnostico',
    'presupuesto_final',
    'en_reparacion',
    'reparado',
    'en_camino_cliente',
    'completado'
] as const;

async function getAuthenticatedClient(userData: typeof USERS.client | typeof USERS.workshop) {
    const client = createClient<Database>(supabaseUrl, supabaseKey, {
        auth: {
            persistSession: false,
            autoRefreshToken: false,
        }
    });

    // Try sign in
    let { data: { session }, error: signInError } = await client.auth.signInWithPassword({
        email: userData.email,
        password: userData.password
    });

    if (signInError) {
        console.log(`Signing up ${userData.email}...`);
        const { data: { user, session: newSession }, error: signUpError } = await client.auth.signUp({
            email: userData.email,
            password: userData.password,
            options: {
                data: { full_name: userData.name }
            }
        });

        if (signUpError) {
            console.error(`Error signing up ${userData.email}:`, signUpError);
            return null;
        }
        session = newSession;

        // Give some time for triggers
        await new Promise(r => setTimeout(r, 2000));
    } else {
        // Session restored
        // console.log("Signed in as " + userData.email);
    }

    if (session?.user) {
        // Always try to ensure profile is correct
        const updateData: any = {
            full_name: userData.name
        };

        if (userData.is_workshop) {
            updateData.is_workshop = true;
        }

        if (userData.is_workshop && 'workshop_name' in userData) {
            updateData.workshop_name = userData.workshop_name;
            updateData.workshop_city = userData.workshop_city;
            updateData.workshop_description = "Especialistas en reparaciones rápidas.";
        }

        // console.log(`Updating profile for ${userData.email}...`);
        const { error: profileError } = await client
            .from('profiles')
            .update(updateData)
            .eq('user_id', session.user.id);

        if (profileError) {
            console.error(`Profile update error for ${userData.email}:`, profileError);
        } else {
            // console.log(`Profile updated for ${userData.email}`);
        }
    }

    return { client, userId: session?.user?.id };
}

async function main() {
    console.log("Authenticating Clients...");
    const clientAuth = await getAuthenticatedClient(USERS.client);
    const workshopAuth = await getAuthenticatedClient(USERS.workshop);

    if (!clientAuth?.userId || !workshopAuth?.userId) {
        console.error("Failed to authenticate users.");
        return;
    }

    const { client: customerClient, userId: customerId } = clientAuth;
    const { client: workshopClient, userId: workshopId } = workshopAuth;

    console.log(`Client ID: ${customerId}`);
    console.log(`Workshop ID: ${workshopId}`);

    // Need to force refresh session sometimes if triggers took too long, but we just signed in so maybe ok.

    // Run multiple iterations to generate enough data for pagination
    const ITERATIONS = 3;

    for (let i = 0; i < ITERATIONS; i++) {
        console.log(`\n=== Iteration ${i + 1}/${ITERATIONS} ===`);

        for (const status of REQUEST_STATES) {
            console.log(`\n--- Creating scenario: ${status} ---`);

            const brands = ['Samsung', 'Apple', 'Xiaomi', 'Sony', 'Oppo'];
            const models = ['Galaxy S23', 'iPhone 15', 'Redmi Note 12', 'Xperia 5', 'Reno 10', 'Galaxy A54', 'iPhone 13', 'POCO F5'];
            const problems = ['Pantalla rota', 'Batería no carga', 'Cámara borrosa', 'No enciende', 'Altavoz no funciona', 'Pantalla azul', 'Conector de carga roto'];
            const cities = ['Madrid', 'Barcelona', 'Valencia', 'Sevilla', 'Bilbao'];

            const randomBrand = brands[Math.floor(Math.random() * brands.length)];
            const randomModel = models[Math.floor(Math.random() * models.length)];
            const randomProblem = problems[Math.floor(Math.random() * problems.length)];
            const randomCity = cities[Math.floor(Math.random() * cities.length)];

            const device = {
                brand: randomBrand,
                model: randomModel,
                type: 'Smartphone',
                problem: `${randomProblem} - ${status} test`,
                category: 'Pantalla',
                images: ['https://images.unsplash.com/photo-1598327773516-20967488a011?auto=format&fit=crop&q=80&w=1000']
            };

            // 1. Create Request (AS CLIENT)
            const { data: request, error: reqError } = await customerClient
                .from('solicitudes')
                .insert({
                    user_id: customerId,
                    device_brand: device.brand,
                    device_model: device.model,
                    device_type: device.type,
                    problem_description: device.problem,
                    problem_category: device.category,
                    city: randomCity,
                    images: device.images,
                    status: 'esperando_ofertas'
                })
                .select()
                .single();

            if (reqError || !request) {
                console.error(`Error creating request:`, reqError);
                continue;
            }
            console.log(`Request created: ${request.id}`);

            if (status === 'esperando_ofertas') continue;

            // 2. Create Offer (AS WORKSHOP)
            const { data: offer, error: offerError } = await workshopClient
                .from('ofertas')
                .insert({
                    solicitud_id: request.id,
                    workshop_id: workshopId,
                    estimated_cost_min: 50 + Math.floor(Math.random() * 50),
                    estimated_cost_max: 100 + Math.floor(Math.random() * 50),
                    diagnosis_cost: 10,
                    transport_cost: 5,
                    estimated_days: 2 + Math.floor(Math.random() * 5),
                    status: 'pendiente'
                })
                .select()
                .single();

            if (offerError || !offer) {
                console.error(`Error creating offer:`, offerError);
                continue;
            }
            console.log(`Offer created: ${offer.id}`);

            if (status === 'oferta_seleccionada' || REQUEST_STATES.indexOf(status) > REQUEST_STATES.indexOf('oferta_seleccionada')) {
                const { error: selectError } = await customerClient
                    .from('solicitudes')
                    .update({
                        selected_offer_id: offer.id,
                        status: 'oferta_seleccionada'
                    })
                    .eq('id', request.id);

                if (selectError) console.error("Error selecting offer:", selectError);

                await workshopClient
                    .from('ofertas')
                    .update({ status: 'aceptada' })
                    .eq('id', offer.id);
            }

            if (REQUEST_STATES.indexOf(status) > REQUEST_STATES.indexOf('oferta_seleccionada')) {
                const { error: statusError } = await workshopClient
                    .from('solicitudes')
                    .update({ status: status as any })
                    .eq('id', request.id);

                if (statusError) console.error(`Error updating status to ${status}:`, statusError);
                else console.log(`Request moved to ${status}`);
            }
        }
    }

    console.log("Seeding completed!");
}

main().catch(console.error);
